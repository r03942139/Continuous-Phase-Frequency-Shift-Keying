/* 
 * Copyright (c) 2009
 * Texas Instruments
 *
 *  All rights reserved.  Property of Texas Instruments
 *  Restricted rights to use, duplicate or disclose this code are
 *  granted through contract.
 * 
 * */
/* THIS FILE WAS GENERATED BY ti.sysbios.genx */

/*
 *  ======== hello.c ========
 */

//#include 	<xdc/std.h>
//#include 	<xdc/runtime/System.h>
//#include 	"gpio.h"
#include	"hw_types.h"
#include 	"hw_emifa2.h"
#include	"hw_gpio.h"			// for handshake i/o 
#include 	<hw_dspcache.h>
#include 	"soc_C6748.h"  // OMAPL138.h"
#include 	"emifa.h"
//#include 	"hw_syscfg0_OMAPL138.h"
#include 	"hw_syscfg0_C6748.h"   //OMAPL138.h"
#include 	"hw_pllc_C6748.h"
#include 	"hw_psc_C6748.h"

#include 	"interrupt.h"
#include 	"edma.h"
//#include  "std.h"			//---- (S0305)
//#include	"osif.h"		//---- (S0305) ref for IntSetup & Interrupt_add

#define		_DEBUG_NEW_DMA
#define		_DEBUG_BUFFER_CHECK

#define     MAX_NUM_SYSEVENTS   128

typedef		unsigned char 		UINT8;
typedef 	unsigned int        UINT32;

typedef struct _IntSetup
{
	UINT8       intVectId;
    UINT8       sysEvtId[MAX_NUM_SYSEVENTS];
    UINT8       sysEvtCount;
    void        (*pCallbackFxn)(void* pCallbackArg);
    void*       pCallbackArg;
    UINT8       bEnable;
} IntSetup;

UINT32  Interrupt_add(IntSetup* myIntSetup);
UINT32  Interrupt_delete(IntSetup* myIntSetup);
UINT32  Interrupt_enable(IntSetup* myIntSetup);
UINT32  Interrupt_disable(IntSetup* myIntSetup);

//--------------------------------------------------------------------------------------------------
//		PLEASE specify DEBUG FLag Below:
//--------------------------------------------------------------------------------------------------
#define		_DEBUG_DMA_TEST_
//#define		_DEBUG_RX_POLLING_

int DMA_CNT = 0;

//--------------------------------------------------------------------------------------------------
//		FUNCTION DECLARATION Below:
//--------------------------------------------------------------------------------------------------
void (*cb_Fxn[EDMA3_NUM_TCC])(unsigned int tcc,
                               unsigned int status, void *appData);
void		F_SetUpEdma(void);
static void SetupINTCInt(void);
void registerEdma3Interrupts();
void enableEdma3Interrupts();

int PSCModuleControl (unsigned int baseAdd, unsigned int moduleId,
                         unsigned int powerDomain, unsigned int flags);
void	F_SetPLL0Div3(void);
void	F_ConfigEmifaIo(void);
// void	myTest(void);
static void	F_SetPaRAM(unsigned int	tccNumber, unsigned int srcBuf, unsigned int dstBuf);
//void	F_FastSetTxPaRAM(unsigned int srcBuf, unsigned int dstBuf);
//void	F_FastSetRxPaRAM(unsigned int srcBuf, unsigned int dstBuf);

static void 	callbackTx(unsigned int tccNum, unsigned int status, void *appData);
static void 	callbackRx(unsigned int tccNum, unsigned int status, void *appData);
void	F_PollingTest(void);



void	F_StartEMIFA(void);

unsigned int	F_SetTxBlkGp(volatile unsigned short *dspTxPtr, unsigned short blk_cnt);
unsigned int	F_SetRxBlkGp(volatile unsigned short *dspRxPtr, unsigned short blk_cnt);
unsigned int	F_TxDmaDone(void);
unsigned int	F_RxDmaDone(void);
unsigned int	RX2_GET_ID(void);
unsigned int	RX2_PUT_ID(void);
unsigned int	TX1_GET_ID(void);
unsigned int	TX1_PUT_ID(void);

#ifdef	 _DEBUG_BUFFER_CHECK
void	F_ChkDbgBuffer(void);
#endif

static void	F_SetDummyPaRAM(unsigned int	tccNumber, unsigned int speed);
//--------------------------------------------------------------------------------------------------
//		CONSTANT Define Below:
//--------------------------------------------------------------------------------------------------
//---------- FPGA MEMORY Interface define ------------------------------- 
#define		C_DSP_MEM_BASE			0x64000000u
#define		C_ADDR_OFST				2
#define		C_BLK_LEN				0x400
#define		C_RX1_BLK_BEGIN			1
#define		C_RX1_BLK_END			7
#define		C_RX2_BLK_BEGIN			8
#define		C_RX2_BLK_END			15
#define		C_TX1_BLK_BEGIN			16
#define		C_TX1_BLK_END			23
#define		C_TX2_BLK_BEGIN			24
#define		C_TX2_BLK_END			31

#define		C_RX2_PUT_ADDR			(C_DSP_MEM_BASE + 0x0100*C_ADDR_OFST) 
#define		C_RX2_GET_ADDR			(C_DSP_MEM_BASE + 0x0101*C_ADDR_OFST)
#define		C_TX1_PUT_ADDR			(C_DSP_MEM_BASE + 0x0200*C_ADDR_OFST)
#define		C_TX1_GET_ADDR			(C_DSP_MEM_BASE + 0x0201*C_ADDR_OFST)


//-------------- EDMA Setting --------------------------------------------
#define		C_ACNT				2
#define		C_BCNT				1024
#define		C_CCNT				1

#define		C_DMA_TX_TCC0		0
#define		C_DMA_RX_TCC1		1

#define		C_DMA_EVQ0			0
#define		C_DMA_EVQ1			1

#define		C_DMA_TX_CH0		0
#define		C_DMA_RX_CH1		1

#define		C_EVQ0				0
#define		C_EVQ1				1
//--------------------------------------------------------------------------------------------------
//		Global Variables:
//--------------------------------------------------------------------------------------------------
static unsigned 	short			V_Rx2BlkId, V_Tx1BlkId,V_Tx1BlkCnt,V_Rx2BlkCnt;
//unsigned	short	DspTxData[8192];
//unsigned	short	DspRxData[8192];
volatile 	unsigned short 	*FpgaTxBuff;
volatile 	unsigned short 	*FpgaRxBuff;
volatile 	unsigned short 	*DspTxBuff;
volatile 	unsigned short 	*DspRxBuff;
unsigned	int				V_TxDmaDone, V_RxDmaDone; 
unsigned 	short			V_TmpW,V_TmpW2;
unsigned 	short			HeadInfo[16]; 
int k;   //DEBUG
//---(S0305) unsigned 	int				V_DspTxPtr,V_DspRxPtr;
volatile unsigned short *V_DspTxPtr;
volatile unsigned short *V_DspRxPtr;





IntSetup    hwi_DmaCc_intSetup;
IntSetup    hwi_DmaErr_intSetup;
/***************************************************************************************************
 * 	UNLOCK function
 * 
 * 
 ***************************************************************************************************/ 
void SysCfgRegistersUnlock(void)
{
     // Unlocking Kick Registers before pinmux configuration 
     HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_KICK0R) = SYSCFG_KICK0R_UNLOCK;
     HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_KICK1R) = SYSCFG_KICK1R_UNLOCK; 
}
/***************************************************************************************************
 * 		LOCK Function
 * 
 * 
 ***************************************************************************************************/  
void SysCfgRegistersLock(void)
{
     // Locking the Kick Registers. 
     HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_KICK0R) = SYSCFG_KICK0R_KICK0;
     HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_KICK1R) = SYSCFG_KICK1R_KICK1;
}
/***************************************************************************************************
 * 		FUNC:	void	F_SetPLL0Div3(void)
 * 		DESC:	config. clock related registers
 * 
 ***************************************************************************************************/  
void	F_SetPLL0Div3(void) {
	SysCfgRegistersUnlock();	
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_CFGCHIP0) &= 0xFFFFFFEF;                                               
    while (HWREG(SOC_PLLC_0_REGS + PLLC_PLLSTAT) & PLLC_PLLSTAT_GOSTAT  ); //Check for the GOSTAT bit in PLLSTAT to clear to 0
    //HWREG(SOC_PLLC_0_REGS + PLLC_PLLDIV3) = 0x00008009;   // En DIV3 for EMIFA & 300/10 = 30M for test
    // 4 isn't fast enough for Rx2: HWREG(SOC_PLLC_0_REGS + PLLC_PLLDIV3) = 0x00008004;   // En DIV3 for EMIFA & 300/5 = 60M for test    (6)/(4)/(2) o.k.
    
    HWREG(SOC_PLLC_0_REGS + PLLC_PLLDIV3) = 0x00008006;   // En DIV3 for EMIFA & 300/5 = 60M for test    (6)/(4)/(2) o.k.
        
    HWREG(SOC_PLLC_0_REGS + PLLC_PLLCMD) |= PLLC_PLLCMD_GOSET; //Wait for the Gostat bit in PLLSTAT to 0, completion of phase alignment) 
    while (HWREG(SOC_PLLC_0_REGS + PLLC_PLLSTAT) & PLLC_PLLSTAT_GOSTAT);
    HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_CFGCHIP0) |= 0x00000010;  //SYSCFG_CFGCHIP0_PLL_MASTER_LOCK


    SysCfgRegistersLock(); 
}	 

/***************************************************************************************************
 * 		FUNC:	void	F_SetNoneCache(void)
 * 		DESC:	config. non-cache blocks used by EMIFA + DMA
 *
 ***************************************************************************************************/
void	F_SetNonCache(void) {
	HWREG(SOC_CACHE_0_REGS + DSPCACHE_MAR(100)) &= ~DSPCACHE_MAR_PC;	// nCS4
	HWREG(SOC_CACHE_0_REGS + DSPCACHE_MAR(101)) &= ~DSPCACHE_MAR_PC;	// nCS4
	HWREG(SOC_CACHE_0_REGS + DSPCACHE_MAR(195)) &= ~DSPCACHE_MAR_PC;	// DDR2
	HWREG(SOC_CACHE_0_REGS + DSPCACHE_MAR(196)) &= ~DSPCACHE_MAR_PC;	// DDR2
}
/***************************************************************************************************
 * 		FUNC:	void	F_ConfigEmifaIo(void)
 * 		DESC:	config. EMIFA related I/O settings (Async. memory interface)
 * 				(S0305): adjust I/O pins for avoid SD card pins
 ***************************************************************************************************/  
void	F_ConfigEmifaIo(void) {
	unsigned int TmpHwReg;

	SysCfgRegistersUnlock();
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(5)) =	0x01000000; 	//	BA[1:0] (no BA(0)

	//---- (S0305)
	//HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(6)) =	0x00000001; 	// 	EMA_WT(1)x + EMA_CLK
	//HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(7)) = 	0x01110100; 	// 	W1x+RnW+ nOE + nWE + nCS5 + nCS4
	//----||
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(6)) =	0x00000008; 	//(S0225) 	EMA_CLK: set as nRESET pin (SD)
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(7)) = 	0x08110180; 	//(S0225) 	RnW:EM_nTX1UF(8) + nOE(1) + nWE(1) + nCS4(1)+ EM_nRX2OV(8)
	//----}

	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(8)) =	0x11111111; 	//  EMA_D[15:8]
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(9)) = 	0x11111111;		// 	EMA_D[7:0]

	//----(S0305) HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(10))=	0x00088800; 	// 	disable EMA_A[16 & up]/use A19~21 as handshake
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(10))=	0x00000000; 	// (S0225): Don't use EMA_A[16 & up]

	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(11))=	0x11111111; 	// 	EMA_A[15:8] 
	HWREG(SOC_SYSCFG_0_REGS + SYSCFG0_PINMUX(12))=	0x11111111; 	// 	EMA_A[7:0]	
	SysCfgRegistersLock();   
	//---- config handshake registers

	//----{ (S0305) move handshake I/O to non-SD related pins
	//TmpHwReg = HWREG(SOC_GPIO_0_REGS + GPIO_DIR(2) );				//  set GP4[3] as nMemRst o/p
	//TmpHwReg &= ~0x00000008;
	//TmpHwReg |= 0x00000030;
	//HWREG(SOC_GPIO_0_REGS + GPIO_DIR(2) ) = TmpHwReg;				//  set GP4[5:4] as Rx2OV & TX1UF i/p
	//HWREG(SOC_GPIO_0_REGS + GPIO_CLR_DATA(2) ) = 0x00000008;		//  set GP4[3]=nMemRst= 0 (reset state)
	//----||
	TmpHwReg = HWREG(SOC_GPIO_0_REGS + GPIO_DIR(1) );				//  set GP2[7] as nMemRst o/p
	TmpHwReg &= ~0x00000080;
	TmpHwReg |= 0x42000000;
	HWREG(SOC_GPIO_0_REGS + GPIO_DIR(1) ) = TmpHwReg;				//  set GP3[14]=Rx2OV & GP3[9]=TX1UF i/p
	HWREG(SOC_GPIO_0_REGS + GPIO_CLR_DATA(1) ) = 0x00000080;		//  set GP2[7]=nMemRst= 0 (reset state)
	//----}
}
 
/***************************************************************************************************
 * 		FUNC:	void EMIFAClkConfig(void)
 * 		DECS:	config. PSC module for EMIFA & I/O interface
 * 
 ***************************************************************************************************/ 
void EMIFAClkConfig(void)
{
    /* Power on the EMIFA */
    PSCModuleControl(SOC_PSC_0_REGS, HW_PSC_EMIFA, PSC_POWERDOMAIN_ALWAYS_ON,
                     PSC_MDCTL_NEXT_ENABLE);
    //---- GPIO for handshake pins ----                    
    PSCModuleControl(SOC_PSC_1_REGS, HW_PSC_GPIO, PSC_POWERDOMAIN_ALWAYS_ON,
		     		PSC_MDCTL_NEXT_ENABLE);                       
}

/***************************************************************************************************
 *		FUNC:		void	F_EmifaReset(void)	 
 * 		DESC:		pulse RESET Pin & init Blk0: management signals 
 * 
 ***************************************************************************************************/
#define		_DEBUG_MEM_  
void	F_EmifaReset(void) 
{
	unsigned short	i;	

#ifdef	_DEBUG_MEM_		
	for (i=0; i<16; i++) {
		HeadInfo[i] = 0; 	
	}
#endif 
				 	
    //---- reset interface ----
	//---- (S0305)
	//HWREG(SOC_GPIO_0_REGS + GPIO_CLR_DATA(2) ) = 0x00000008;			//  set GP4[3]=nMemRst= 0 (reset)
	//----||
	 HWREG(SOC_GPIO_0_REGS + GPIO_CLR_DATA(1) ) = 0x00000080;			//  set GP2[7]=nMemRst= 0 (reset)
	//----}
	for (i=0; i<0x200; i++) {};
	HWREGH(C_RX2_GET_ADDR) =   	8; 		//--(S0305) C_RX2_BLK_BEGIN;	// 8
	HWREGH(C_RX2_PUT_ADDR) = 	15; 	// 8	// preset Put for FPGA
 	HWREGH(C_TX1_PUT_ADDR) =   	C_TX1_BLK_BEGIN; 	// 16
 	HWREGH(C_TX1_GET_ADDR) =   	C_TX1_BLK_END; 	 	// 23

#ifdef	_DEBUG_MEM_ 	
 	HeadInfo[0] = HWREGH(C_RX2_GET_ADDR);
 	HeadInfo[1] = HWREGH(C_RX2_PUT_ADDR);
 	HeadInfo[2] = HWREGH(C_TX1_PUT_ADDR);
	HeadInfo[3] = HWREGH(C_TX1_GET_ADDR);
	
 	HeadInfo[4] = HWREGH(C_RX2_GET_ADDR);
 	HeadInfo[5] = HWREGH(C_RX2_PUT_ADDR);
 	HeadInfo[6] = HWREGH(C_TX1_PUT_ADDR);
	HeadInfo[7] = HWREGH(C_TX1_GET_ADDR);	
#endif	
	for (i=0; i<0x201; i++) {};
	//----{ (S0305)
	//HWREG(SOC_GPIO_0_REGS + GPIO_SET_DATA(2) ) = 0x00000008;			//  set GP4[3]=nMemRst= 1 (release reset)
	//----||
	HWREG(SOC_GPIO_0_REGS + GPIO_SET_DATA(1) ) = 0x00000080;			//  set GP4[3]=nMemRst= 1 (release reset)
	//----}
} 

// --------------------------------------------------------------------------------------------------
// 
// 				EDMA...
// 
// --------------------------------------------------------------------------------------------------
/***************************************************************************************************
 * 		FUNC:	void	F_StartEMIFA(void)
 *		DESC:	DMA mode EMIFA testing
 *
 ***************************************************************************************************/
//----------------------------------------------------------------------------------------------
void	F_StartEMIFA(void) {
	SetupINTCInt();
	//-----------------------------------------------------
	F_SetPLL0Div3(); 		// set EMIFA clock
	F_SetNonCache(); 		// (S0305)
	EMIFAClkConfig();
    F_ConfigEmifaIo();		//---- EMIFA I/O Config.
    //---- set EMIFA ASY. Mode for nCS4
    HWREG(SOC_EMIFA_0_REGS + EMIFA_CE4CFG) = 0x00000001u; // set normal mode, no wait, 16 bit
    F_EmifaReset();
    //---- define DEBUG flag for selecting POLLING and DMA mode
    F_SetUpEdma();
    //F_DmaTest();
    //------------------------ parameter setup
	V_Tx1BlkId = C_TX1_BLK_BEGIN-1;							//(S0318) s0318 skill to solve initial problem
	V_Rx2BlkId = C_RX2_BLK_BEGIN; 						//(S0318) skill to solve initial prob. C_RX2_BLK_END;		//(S0318) (S0305) for the first time problem.
#ifdef	_DEBUG_NEW_DMA
	V_TxDmaDone = 1;
	V_RxDmaDone = 1;
#else
	V_TxDmaDone = 0;										// init with 0
	V_RxDmaDone = 0; 										// DISABLE RX
#endif
}





//----------------------------------------------------------------------------------------------
#ifdef	_DEBUG_NEW_DMA
/***************************************************************************************************
 * 		FUNC:	unsigned int F_SetTxBlkGp(volatile unsigned short *dspTxPtr, unsigned short blk_cnt)
 *		DESC:	TX blk_cnt of blocks words from TxBuffer where the start address is pointed by dspTxPtr.
 *				Return(0) if O.K.
 *				Return(1) if new TX is not ready...
 ***************************************************************************************************/
unsigned int	F_SetTxBlkGp(volatile unsigned short *dspTxPtr, unsigned short blk_cnt) {
	//printf("\n ");
	if (V_TxDmaDone!=1)
		return(1);											// TX DMA in progress
	V_Tx1BlkCnt = blk_cnt + 1;								// need add one blk for dummy start blk
	V_DspTxPtr  = (unsigned short *) dspTxPtr;
	V_TxDmaDone = 0;
	F_SetDummyPaRAM(C_DMA_TX_TCC0, 1);						//fast
	EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);			// EN TX DMA
	return(0);
}
/***************************************************************************************************
 * 		FUNC:	unsigned int F_SetRxBlkGp(volatile unsigned short *dspRxPtr, unsigned short blk_cnt)
 *		DESC:	RX blk_cnt of blocks words into RxBuffer where the start address is pointed by dspRxPtr.
 *				Return(0) if O.K.
 *				Return(1) if new RX is not ready...
 ***************************************************************************************************/
unsigned int	F_SetRxBlkGp(volatile unsigned short *dspRxPtr, unsigned short blk_cnt) {
	//printf("\n ");
	if (V_RxDmaDone!=1)
		return(1);											// RX DMA in progress
	V_Rx2BlkCnt = blk_cnt; // (S0318) don't need add one + 1;
	V_DspRxPtr 	= (unsigned short *) dspRxPtr;    //V_DspRxPtr  = V_DspRxPtr - C_BLK_LEN;					// (S0318) for init dummy
	V_RxDmaDone = 0;
	F_SetDummyPaRAM(C_DMA_RX_TCC1, 1);
	EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);			// EN TX DMA
	return(0);
}

/***************************************************************************************************
 * 		FUNC:	unsigned int F_TxDmaDone(void)
 *		DESC:	Check if all TX DMA blocks have been sent.
 *				Return(1) if done.
 *				Return(other value) if busy or pending...
 ***************************************************************************************************/
unsigned int	F_TxDmaDone(void) {
	return(V_TxDmaDone);
}
/***************************************************************************************************
 * 		FUNC:	unsigned int F_RxDmaDone(void)
 *		DESC:	Check if all RX DMA blocks have been received.
 *				Return(1) if done.
 *				Return(other value) if busy or pending...
 ***************************************************************************************************/
unsigned int	F_RxDmaDone(void) {
	return(V_RxDmaDone);
}
//----------------------------------------------------------------------------------------------

#endif



unsigned int	RX2_GET_ID(void) {
	return(HWREGH(C_RX2_GET_ADDR));
}
unsigned int	RX2_PUT_ID(void) {
	return(HWREGH(C_RX2_PUT_ADDR));
}

unsigned int	TX1_GET_ID(void) {
	return(HWREGH(C_TX1_GET_ADDR));
}
unsigned int	TX1_PUT_ID(void) {
	return(HWREGH(C_TX1_PUT_ADDR));
}





/***************************************************************************************************
 * 		FUNC:	void	F_SetUpEdma(void)
 * 		DESC:	config. EDMA CC0 for EMIFA interface
 * 
 ***************************************************************************************************/ 
void	F_SetUpEdma(void) {
    //----(S0305) volatile unsigned int 	index = 0;
    //----(S0305) volatile unsigned int 	count = 0;
    //EDMA3CCPaRAMEntry 		paramSet;
    // unsigned int 			retVal = 0u;
    unsigned int 			retValTx = 0u;   
    unsigned int 			retValRx = 0u;    
    // unsigned int 			numenabled = 0u;
    //----(S0305) unsigned short			i;
    //--------- SetUp Power & INTs ---------------------------------------------------

    PSCModuleControl(SOC_PSC_0_REGS, 0, 0, PSC_MDCTL_NEXT_ENABLE);		// Enabling the PSC for EDMA3CC_0.   
    PSCModuleControl(SOC_PSC_0_REGS, 1, 0, PSC_MDCTL_NEXT_ENABLE);		// Enabling the PSC for EDMA3TC_0.	// TX
    PSCModuleControl(SOC_PSC_0_REGS, 2, 0, PSC_MDCTL_NEXT_ENABLE);		// Enabling the PSC for EDMA3TC_1.	// RX (D0709)    
	//----(S0305) SetupINTCInt();
    EDMA3Init(SOC_EDMA30CC_0_REGS, C_EVQ0);
    EDMA3Init(SOC_EDMA30CC_0_REGS, C_EVQ1);    
    //----(S0305)    registerEdma3Interrupts();
    // ways to release EDMA3:	EDMA3Deinit(SOC_EDMA30CC_0_REGS, evtQ);

    //--------- Buffer Init ----------------------------------------------------------
    //---- srcBuff = (unsigned short *)	_srcBuff;
    //----(S0305) FpgaTxBuff = (unsigned short *)	(C_DSP_MEM_BASE + C_TX1_BLK_BEGIN * C_BLK_LEN * C_ADDR_OFST);
    //----(S0305) FpgaRxBuff = (unsigned short *)	(C_DSP_MEM_BASE + C_RX2_BLK_BEGIN * C_BLK_LEN * C_ADDR_OFST);
    /*for (i=0; i<8192; i++) {
    	//if(i%128>64)
    		//DspTxData[i] = 0xFFFF;
    	//else
    	DspTxData[i] = 0;
    	DspRxData[i] = 0; 
    }*/

    //----(S0305) DspTxBuff	= (unsigned short *)	DspTxData;
    //----(S0305) DspRxBuff	= (unsigned short *)	DspRxData;

    //---------- Request DMA channel and TCC -----------------------------------------
    retValTx  = EDMA3RequestChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, C_DMA_TX_CH0, C_DMA_TX_TCC0, C_DMA_EVQ0);   
    retValRx  = EDMA3RequestChannel(SOC_EDMA30CC_0_REGS, EDMA3_CHANNEL_TYPE_DMA, C_DMA_RX_CH1, C_DMA_RX_TCC1, C_DMA_EVQ1);
    if 	(	(retValTx!=TRUE) || (retValRx != TRUE) 	) {
    	while (1) {}; 	
    }	
    cb_Fxn[C_DMA_TX_TCC0] = &callbackTx; 		// Registering Callback Function    
    cb_Fxn[C_DMA_RX_TCC1] = &callbackRx; 		// Registering Callback Function
    //---- { (S0305) reg. & init. interrupt here
    registerEdma3Interrupts();
    enableEdma3Interrupts();
 	//---------- Set PaRam parameters 
 	//----(S0305) F_SetPaRAM(C_DMA_TX_TCC0, (unsigned int) DspTxBuff, 	(unsigned int) FpgaTxBuff);
 	//----(S0305) F_SetPaRAM(C_DMA_RX_TCC1, (unsigned int) FpgaTxBuff, 	(unsigned int) DspRxBuff);
 	//---------- Start DMA Transfer & Flow control ------------------------------------
	return;	
}	



/***************************************************************************************************
 * 	FUNCTION: 	void	F_SetTxParaRAM(pRamId, srcBuf, dstBuf) 
 * 	DESCRIPTION: 	Tx: tccNum = 0; using paRamId = 0
 * 					
 ***************************************************************************************************/
static void	F_SetPaRAM(unsigned int	tccNumber, unsigned int srcBuf, unsigned int dstBuf) {
unsigned int	i;	
unsigned int *sr;
volatile 	unsigned int *ds;
EDMA3CCPaRAMEntry 		paramSet;	
   	//---------- Fill the PaRAM Set with transfer specific information (AB-Sync)-------
    paramSet.srcAddr    = (unsigned int)(srcBuf);
    paramSet.destAddr   = (unsigned int)(dstBuf);    
    paramSet.aCnt = (unsigned short)	C_ACNT;
    paramSet.bCnt = (unsigned short)	C_BCNT;
    paramSet.cCnt = (unsigned short)	C_CCNT;
    
    //---- Setting up the SRC/DES Index 
    paramSet.srcBIdx = 	(short)		C_ACNT;
    paramSet.destBIdx = (short)		C_ACNT;
    //----   AB Sync Transfer Mode
    paramSet.srcCIdx = ((short) C_ACNT * (short) C_BCNT);
    paramSet.destCIdx = ((short)C_ACNT * (short) C_BCNT);
    //-------------------------
    paramSet.linkAddr 	= (unsigned short)0xFFFFu;
    paramSet.bCntReload = (unsigned short)0u;    
    //======================== OPT fields ========================================================
    paramSet.opt = 0u;   
    paramSet.opt &= 0xFFFFFFFCu;		 						//  Src & Dest are in INCR modes     
    paramSet.opt |= ((tccNumber << EDMA3CC_OPT_TCC_SHIFT) & EDMA3CC_OPT_TCC);	// Program the TCC 
    paramSet.opt |= 	(1 << EDMA3CC_OPT_ITCINTEN_SHIFT);					// intermediate INT	
    paramSet.opt |= 	(1 << EDMA3CC_OPT_TCINTEN_SHIFT);					// final INT
    paramSet.opt |= 	(1 << EDMA3CC_OPT_SYNCDIM_SHIFT); 					//	AB sync. 
    //------------------------------------------------------------------- Now, write the PaRAM Set. 
    //if (tccNumber==0)	//TX: TCC0 
    //	EDMA3SetPaRAM(SOC_EDMA30CC_0_REGS, 0, &paramSet);	// use PaRamId=0
    //else			
    //	EDMA3SetPaRAM(SOC_EDMA30CC_0_REGS, 1, &paramSet);   // use PaRamId=1 	

 	sr = (unsigned int *)	&paramSet;
 	if (tccNumber==0) 
    	ds = (unsigned int *)(SOC_EDMA30CC_0_REGS + EDMA3CC_OPT(0));	// TX=TCC0=CH0
	else
    	ds = (unsigned int *)(SOC_EDMA30CC_0_REGS + EDMA3CC_OPT(1));	// RX=TCC1=CH1
    		
    for(i=0; i < EDMA3CC_PARAM_ENTRY_FIELDS; i++)
    {
        *ds = *sr;
        ds++;
        sr++;
    }    	    	
}	

/***************************************************************************************************
 * 	FUNCTION: 	void	F_SetDummyPaRam(unsigned int	tccNumber, unsigned int speed)
 * 	DESCRIPTION: 	Tx: tccNum = 0; using paRamId = 0
 * 					speed: decides how many dummy words to be transfered
 *
 ***************************************************************************************************/
static	unsigned short DummySrc, DummyDest;
static	void	F_SetDummyPaRAM(unsigned int	tccNumber, unsigned int speed) {
unsigned int	i;
unsigned int 	*sr;
volatile 	unsigned int *ds;
EDMA3CCPaRAMEntry 		paramSet;
	i = speed;
   	//---------- Fill the PaRAM Set with transfer specific information (AB-Sync)-------
    paramSet.srcAddr    = (unsigned int)	(&DummySrc);
    paramSet.destAddr   = (unsigned int) 	(&DummyDest);
    paramSet.aCnt = (unsigned short)	i;
    paramSet.bCnt = (unsigned short)	1;
    paramSet.cCnt = (unsigned short)	1;

    //---- Setting up the SRC/DES Index
    paramSet.srcBIdx = 	i;
    paramSet.destBIdx = i;
    //----   AB Sync Transfer Mode
    paramSet.srcCIdx =  i;
    paramSet.destCIdx = i;
    //-------------------------
    paramSet.linkAddr 	= (unsigned short)0xFFFFu;
    paramSet.bCntReload = (unsigned short)0u;
    //======================== OPT fields ========================================================
    paramSet.opt = 0x00100107u;
    paramSet.opt |= ((tccNumber << EDMA3CC_OPT_TCC_SHIFT) & EDMA3CC_OPT_TCC);	// Program the TCC
    //------------------------------------------------------------------- Now, write the PaRAM Set.
 	sr = (unsigned int *)	&paramSet;
 	if (tccNumber==0)
    	ds = (unsigned int *)(SOC_EDMA30CC_0_REGS + EDMA3CC_OPT(0));	// TX=TCC0=CH0
	else
    	ds = (unsigned int *)(SOC_EDMA30CC_0_REGS + EDMA3CC_OPT(1));	// RX=TCC1=CH1

    for(i=0; i < EDMA3CC_PARAM_ENTRY_FIELDS; i++)
    {
        *ds = *sr;
        ds++;
        sr++;
    }
}

/***************************************************************************************************
 *		FUNC:	 
 * 		DESC:	
 * 
 ***************************************************************************************************/
static void edma3CCComplIsr();
static void edma3CCErrIsr();
void registerEdma3Interrupts()
{

    UINT32      retVal;

    /* Register Interrupts Here */
    /******************** Completion Interrupt ********************************/
    //IntRegister(7, edma3CCComplIsr);  //(S0225)
    //IntEventMap(7, SYS_INT_EDMA3_0_CC0_INT1);
    //IntEnable(7);
    /********************** CC Error Interrupt ********************************/
	//#ifdef _TMS320C6X
    //IntRegister(8, edma3CCErrIsr);
    //IntEventMap(8, SYS_INT_EDMA3_0_CC0_ERRINT);
    //IntEnable(8);

	    /* Setup the Rx Int using NDK's Interrupt Manager */

	    hwi_DmaCc_intSetup.intVectId =   7;			// 5/6 used by ethernet
	    hwi_DmaCc_intSetup.sysEvtCount = 1;
	    hwi_DmaCc_intSetup.sysEvtId[0] = SYS_INT_EDMA3_0_CC0_INT1; //8
	    hwi_DmaCc_intSetup.pCallbackFxn = edma3CCComplIsr;
	    hwi_DmaCc_intSetup.pCallbackArg = 0;
	    hwi_DmaCc_intSetup.bEnable = 0;
	    retVal = Interrupt_add(&hwi_DmaCc_intSetup);
	    if(retVal != 0)
	        printf("Error setting up DMA_Complete Interrupts \n");


	  //    Setup the Tx Int using NDK's Interrupt Manager
	    hwi_DmaErr_intSetup.intVectId = 8;
	    hwi_DmaErr_intSetup.sysEvtCount = 1;
	    hwi_DmaErr_intSetup.sysEvtId[0] = SYS_INT_EDMA3_0_CC0_ERRINT;
	    hwi_DmaErr_intSetup.pCallbackFxn = edma3CCErrIsr;
	    hwi_DmaErr_intSetup.pCallbackArg = 0;
	    hwi_DmaErr_intSetup.bEnable = 0;
	    retVal = Interrupt_add(&hwi_DmaErr_intSetup);
	    if(retVal != 0)
	        printf("Error setting up DMA_Error Interrupts \n");

}

void enableEdma3Interrupts()
{
    EDMA3ClrIntr(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);
    EDMA3ClrIntr(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);
    EDMA3EnableDmaEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);
    EDMA3EnableDmaEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);
}


/****************************************************************************************************
 * edma3CCComplIsr
 * \brief   ISR for successful transfer completion.
 *
 * \note    This function first disables its own interrupt to make it non-
 *          entrant.
 *
 * \return  None.
 ****************************************************************************************************/
static void edma3CCComplIsr()
{
    volatile unsigned int pendingIrqs;
    volatile unsigned int isIPR = 0;

    unsigned int indexl;
    unsigned int Cnt = 0;
    indexl = 1u;

	//#ifdef _TMS320C6X
    IntEventClear(SYS_INT_EDMA3_0_CC0_INT1);

    isIPR = EDMA3GetIntrStatus(SOC_EDMA30CC_0_REGS);
    if(isIPR)	{
        while ((Cnt < EDMA3CC_COMPL_HANDLER_RETRY_COUNT)&& (indexl != 0u))	{
        	indexl = 0u;
        	pendingIrqs = EDMA3GetIntrStatus(SOC_EDMA30CC_0_REGS);
        	while (pendingIrqs)	{
        		if(TRUE == (pendingIrqs & 1u))	{
                /**
                 * If the user has not given any callback function
                 * while requesting the TCC, its TCC specific bit
                 * in the IPR register will NOT be cleared.
                 */
                /* Here write to ICR to clear the corresponding IPR bits */
                	EDMA3ClrIntr(SOC_EDMA30CC_0_REGS, indexl);
                    (*cb_Fxn[indexl])(indexl, EDMA3_XFER_COMPLETE, NULL);
                }
                ++indexl;
                pendingIrqs >>= 1u;
        	}
            Cnt++;
    	}
    }
}

/***************************************************************************************************
 *		FUNC:		void edma3CCErrIsr()	 
 * 		DESC:		Interrupt ISR for Channel controller error.
 * 
 ***************************************************************************************************/ 
static void edma3CCErrIsr()
{
    volatile unsigned int pendingIrqs;
    unsigned int Cnt = 0u;
    unsigned int index;
    unsigned int evtqueNum = 0;  /* Event Queue Num */

    pendingIrqs = 0u;
    index = 1u;

	//#ifdef _TMS320C6X
    IntEventClear(SYS_INT_EDMA3_0_CC0_ERRINT);

    if((EDMA3GetErrIntrStatus(SOC_EDMA30CC_0_REGS) != 0 )
        || (EDMA3QdmaGetErrIntrStatus(SOC_EDMA30CC_0_REGS) != 0)
        || (EDMA3GetCCErrStatus(SOC_EDMA30CC_0_REGS) != 0))		{
        /* Loop for EDMA3CC_ERR_HANDLER_RETRY_COUNT number of time,
         * breaks when no pending interrupt is found 
         */
        while ((Cnt < EDMA3CC_ERR_HANDLER_RETRY_COUNT)
                    && (index != 0u))					{
       		index = 0u;
            pendingIrqs = EDMA3GetErrIntrStatus(SOC_EDMA30CC_0_REGS);
            while (pendingIrqs)		{
            	/*Process all the pending interrupts*/
           	 	if(TRUE == (pendingIrqs & 1u))	{
                	/* Write to EMCR to clear the corresponding EMR bits.*/
                	/*Clear any SER*/
                	EDMA3ClrMissEvt(SOC_EDMA30CC_0_REGS, index);
               	}
               	++index;
               	pendingIrqs >>= 1u;
            }
            	
            index = 0u;
            pendingIrqs = EDMA3QdmaGetErrIntrStatus(SOC_EDMA30CC_0_REGS);
            while (pendingIrqs)		{
                /*Process all the pending interrupts*/
            	if(TRUE == (pendingIrqs & 1u)) {
            		/* Here write to QEMCR to clear the corresponding QEMR bits*/
                    /*Clear any QSER*/
                    EDMA3QdmaClrMissEvt(SOC_EDMA30CC_0_REGS, index);
                }
                ++index;
                pendingIrqs >>= 1u;
            }
            	
        	index = 0u;
            pendingIrqs = EDMA3GetCCErrStatus(SOC_EDMA30CC_0_REGS);
            if (pendingIrqs != 0u)	{
            	/* Process all the pending CC error interrupts. */
            	/* Queue threshold error for different event queues.*/
            	for (evtqueNum = 0u; evtqueNum < SOC_EDMA3_NUM_EVQUE; evtqueNum++)	{
                	if((pendingIrqs & (1u << evtqueNum)) != 0u)		{
                        /* Clear the error interrupt. */
                        EDMA3ClrCCErr(SOC_EDMA30CC_0_REGS, (1u << evtqueNum));
                    }
                }

            	/* Transfer completion code error. */
            	if ((pendingIrqs & (1 << EDMA3CC_CCERR_TCCERR_SHIFT)) != 0u)	{
               	 	EDMA3ClrCCErr(SOC_EDMA30CC_0_REGS, 
                                  (0x01u << EDMA3CC_CCERR_TCCERR_SHIFT));
            	}
                ++index;
            }
            Cnt++;       
        }
    }   
}     
/****************************************************************************************************
*  	This function invokes necessary functions to configure the ARM
*  	processor and ARM Interrupt Controller(AINTC) to receive and
*  	handle interrupts.
****************************************************************************************************/
static void SetupINTCInt(void)
{
#ifdef	_DEBUG_NO 			//----(S0305)
    IntDSPINTCInit();
    IntGlobalEnable();
#endif
}

/****************************************************************************************************
 * 
 *			Callback function: TX
 *  
 ****************************************************************************************************/
/* Callback function */

static void callbackTx(unsigned int tccNum, unsigned int status, void *appData)
{
    (void)tccNum;
    (void)appData;

    unsigned short 		tx1Id, fpgaTx1Get; //, dspTx1Put;


    if(EDMA3_XFER_COMPLETE == status)
    {
#ifdef	_DEBUG_NEW_DMA	//---- (S0305)
    	if (V_Tx1BlkCnt != 0)
    		V_Tx1BlkCnt -= 1;    				// more blk transfer need. ; Maybe the last response for last sent, no more.
    	//---- check out the Next TxBlkId if available
    	if (V_Tx1BlkId == C_TX1_BLK_END) {
    		tx1Id = C_TX1_BLK_BEGIN;
    	} else {
    		tx1Id = V_Tx1BlkId + 1;
    	}

    	//--------------------------------------------
    	fpgaTx1Get 	= HWREGH(C_TX1_GET_ADDR);
    	//printf("fpgaTx1Get=%d",fpgaTx1Get);
    	//dspTx1Put 	= HWREGH(C_TX1_PUT_ADDR);
    	if (tx1Id != fpgaTx1Get) {				// NEXT Slot available
    		//V_Tx1BlkId = tx1Id;
    		HWREGH(C_TX1_PUT_ADDR) = tx1Id; //---- MUST (S0318) V_Tx1BlkId;				// register next blkId which to be filled with next 1K data
    		if (V_Tx1BlkCnt) {
    			V_TxDmaDone = 0;
    			FpgaTxBuff 	= (unsigned short *)	(C_DSP_MEM_BASE + (V_Tx1BlkId+1) * C_BLK_LEN * C_ADDR_OFST); //(???)
    			F_SetPaRAM(C_DMA_TX_TCC0, (unsigned int) V_DspTxPtr, (unsigned int) FpgaTxBuff);
        		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);			// EN TX DMA
        		V_DspTxPtr	= V_DspTxPtr + C_BLK_LEN;					// must be here update DSP Tx Buffer Ptr to the head of the next 1024W
        		V_Tx1BlkId = tx1Id;								//----(S0318) MUST: Only update V_Tx1BlkId if not finished yet. [ Not update for the next TxGp request ]
    		} else
    			V_TxDmaDone = 1; 								// ALL blk Tx completed
    	} else {												// NEXT Slot unavailable, assign dummy & wait later
    		//---- V_TxDmaDone = 0;
    		V_Tx1BlkCnt += 1;
    		V_TxDmaDone = 0x000D;								// cnt + 1; don't update V_Tx1BlkId & send dummy blk
    		F_SetDummyPaRAM(C_DMA_TX_TCC0, 128);
    		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);			// EN TX DMA
    	}
#else
    	//V_TxDmaDone = 1;	// Transfer completed successfully
    	if (V_Tx1BlkCnt != 0)
    		V_Tx1BlkCnt -= 1;    				// more blk transfer need...
    	//---- check out the Next TxBlkId if available
    	if (V_Tx1BlkId == C_TX1_BLK_END) {
    		tx1Id = C_TX1_BLK_BEGIN;
    	} else {
    		tx1Id = V_Tx1BlkId + 1;
    	}
    	//--------------------------------------------
    	fpgaTx1Get 	= HWREGH(C_TX1_GET_ADDR);
    	//dspTx1Put 	= HWREGH(C_TX1_PUT_ADDR);
    	if (tx1Id != fpgaTx1Get) {				// NEXT Slot available
    		V_Tx1BlkId = tx1Id;
    		HWREGH(C_TX1_PUT_ADDR) = V_Tx1BlkId;				// register next blkId which to be filled with next 1K data
    		if (V_Tx1BlkCnt) {
    			V_TxDmaDone = 0;
    			FpgaTxBuff 	= (unsigned short *)	(C_DSP_MEM_BASE + (V_Tx1BlkId-1) * C_BLK_LEN * C_ADDR_OFST);
    			F_SetPaRAM(C_DMA_TX_TCC0, (unsigned int) V_DspTxPtr, (unsigned int) FpgaTxBuff);
        		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);			// EN TX DMA
        		V_DspTxPtr	= V_DspTxPtr + C_BLK_LEN;					// must be here update DSP Tx Buffer Ptr to the head of the next 1024W
    		} else
    			V_TxDmaDone = 1; 								// ALL blk Tx completed
    	} else {												// NEXT Slot unavailable, assign dummy & wait later
    		V_TxDmaDone = 0;
    		V_Tx1BlkCnt += 1;
    		V_TxDmaDone = 0x000D;								// cnt + 1; don't update V_Tx1BlkId & send dummy blk
    		F_SetDummyPaRAM(C_DMA_TX_TCC0, 128);
    		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_TX_CH0);			// EN TX DMA
    	}


    	// irqRaised = 1;
#endif
    }
    
    else if(EDMA3_CC_DMA_EVT_MISS == status)
    {
            V_TxDmaDone = 2;	//  Transfer resulted in DMA event miss error.
            // irqRaised = -1;
    }
     
    else if(EDMA3_CC_QDMA_EVT_MISS == status)
    {
    		V_TxDmaDone = 3; 		// Transfer resulted in QDMA event miss error. 
            // irqRaised = -2;
    }
}

/****************************************************************************************************
 * 
 *			Callback function: RX
 *  
 ****************************************************************************************************/
/* Callback function */
static void callbackRx(unsigned int tccNum, unsigned int status, void *appData)
{
    (void)tccNum;
    (void)appData;
    unsigned short 		rx2Id, fpgaRx2Put;

    if(EDMA3_XFER_COMPLETE == status)
    {
#ifdef	_DEBUG_NEW_DMA
    	if (V_Rx2BlkCnt != 0)  {
    		V_Rx2BlkCnt -= 1;   		// more blk transfer need...
        	//---- check out the Next TxBlkId if available
        	if (V_Rx2BlkId == C_RX2_BLK_END)
        		rx2Id = C_RX2_BLK_BEGIN;
        	else
        		rx2Id = V_Rx2BlkId + 1;

        	fpgaRx2Put 	= HWREGH(C_RX2_PUT_ADDR);
        	//printf("fpgaRx2Put=%d",fpgaRx2Put);
        	if (rx2Id != fpgaRx2Put) {								// NEXT Slot available
        		V_Rx2BlkId = rx2Id;
        		HWREGH(C_RX2_GET_ADDR) = V_Rx2BlkId;				// register next blkId which to be filled with next 1K data
        		//printf("fpgaRx2Get=%d",HWREGH(C_RX2_GET_ADDR));
        		//if (V_Rx2BlkCnt) {
        		V_RxDmaDone = 0;
        		FpgaRxBuff 	= (unsigned short *)	(C_DSP_MEM_BASE + V_Rx2BlkId * C_BLK_LEN * C_ADDR_OFST); //(???)
        		F_SetPaRAM(C_DMA_RX_TCC1, (unsigned int) FpgaRxBuff, 	(unsigned int) V_DspRxPtr);
        		V_DspRxPtr	= V_DspRxPtr + C_BLK_LEN;	// must be here...
        		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);			// EN RX DMA
        		//} else
        		//	V_RxDmaDone = 1; 								// ALL blk Tx completed
        	} else {												// NEXT Slot unavailable, assign dummy & wait later
        		V_Rx2BlkCnt += 1;
        		V_RxDmaDone = 0x000D;								// cnt + 1; don't update V_Tx1BlkId & send dummy blk
        		F_SetDummyPaRAM(C_DMA_RX_TCC1, 128);
        		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);		// EN RX DMA
        	}
    	} else {
    		V_RxDmaDone = 1; 										// ALL blk Rx completed
    	}
#else

            //V_RxDmaDone = 1;	// Transfer completed successfully
    	if (V_Rx2BlkCnt != 0)
    		V_Rx2BlkCnt -= 1;    				// more blk transfer need...
    	//---- check out the Next TxBlkId if available
    	if (V_Rx2BlkId == C_RX2_BLK_END) {
    		rx2Id = C_RX2_BLK_BEGIN;
    	} else {
    		rx2Id = V_Rx2BlkId + 1;
    	}
    	//--------------------------------------------
    	fpgaRx2Put 	= HWREGH(C_RX2_PUT_ADDR);
    	if (rx2Id != fpgaRx2Put) {				// NEXT Slot available
    		V_Rx2BlkId = rx2Id;
    		HWREGH(C_RX2_GET_ADDR) = V_Rx2BlkId;				// register next blkId which to be filled with next 1K data
    		if (V_Rx2BlkCnt) {
    			V_RxDmaDone = 0;
    			FpgaRxBuff 	= (unsigned short *)	(C_DSP_MEM_BASE + (V_Rx2BlkId-1) * C_BLK_LEN * C_ADDR_OFST);
    			F_SetPaRAM(C_DMA_RX_TCC1, (unsigned int) FpgaRxBuff, 	(unsigned int) V_DspRxPtr);
    			V_DspRxPtr	= V_DspRxPtr + C_BLK_LEN;	// must be here...
    			EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);			// EN RX DMA
    		} else
    			V_RxDmaDone = 1; 								// ALL blk Tx completed
    	} else {						// NEXT Slot unavailable, assign dummy & wait later
    		V_RxDmaDone = 0;
    		V_Rx2BlkCnt += 1;
    		V_RxDmaDone = 0x000D;								// cnt + 1; don't update V_Tx1BlkId & send dummy blk
    		F_SetDummyPaRAM(C_DMA_RX_TCC1, 128);
    		EDMA3SetEvt(SOC_EDMA30CC_0_REGS, C_DMA_RX_CH1);		// EN RX DMA
    	}




#endif
            //irqRaised = 1;
    }
    
    else if(EDMA3_CC_DMA_EVT_MISS == status)
    {             
            V_RxDmaDone = 2;	//  Transfer resulted in DMA event miss error.
            //irqRaised = -1;
    }
     
    else if(EDMA3_CC_QDMA_EVT_MISS == status)
    {
    		V_RxDmaDone = 3; 		// Transfer resulted in QDMA event miss error. 
            //irqRaised = -2;
    }
}



//---------------------------------------------------------------------------------------------------
#ifdef	_DEBUG_BUFFER_CHECK

unsigned short DbgTxBuf[8192];
unsigned short DbgRxBuf[8192];
void	F_ChkDbgBuffer(void) {
unsigned short i;
unsigned short *dbgPtr;

	dbgPtr 	= (unsigned short *)	(C_DSP_MEM_BASE + C_TX1_BLK_BEGIN * C_BLK_LEN * C_ADDR_OFST); //(???)
	for (i=0; i<8192;i++) {
		DbgTxBuf[i] = *(dbgPtr + i);
	}
	dbgPtr 	= (unsigned short *)	(C_DSP_MEM_BASE + C_RX2_BLK_BEGIN * C_BLK_LEN * C_ADDR_OFST); //(???)
	for (i=0; i<8192;i++) {
		DbgRxBuf[i] = *(dbgPtr + i);
	}
}
#endif
